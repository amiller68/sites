#!/usr/bin/env bash

# NOTE (amiller68): assumes that utils are already
#  sourced by the calling script

# error if project root is not set
if [ -z "$PROJECT_ROOT" ]; then
    echo -e "${RED}Error: PROJECT_ROOT not set.${NC}"
    exit 1
fi

# Function to source project configuration with validation
source_project_config() {
    if [ -f "$PROJECT_ROOT/.env.project" ]; then
        source "$PROJECT_ROOT/.env.project"
    else
        echo -e "${RED}Error: .env.project not found. Please create it with PROJECT_NAME and DEFAULT_STAGE.${NC}"
        return 1
    fi
    if [ ! -f "$PROJECT_ROOT/.env.vault" ]; then
        echo -e "${RED}Error: .env.vault not found. Please create it with your OP vault items.${NC}"
        return 1
    fi

    # Validate required variables
    local required_vars=("PROJECT_NAME" "CLOUD_VAULT" "SERVICES" "DNS_ROOT_ZONES" "USE_PRIVATE_REPOS")
    local missing_vars=()

    for var in "${required_vars[@]}"; do
        # Use eval to safely check if variable is set and non-empty
        local val=""
        eval "val=\${$var:-}"
        if [ -z "$val" ]; then
            missing_vars+=("$var")
        fi
    done

    if [ ${#missing_vars[@]} -gt 0 ]; then
        echo -e "${RED}Error: Missing required variables in .env.project:${NC}"
        for var in "${missing_vars[@]}"; do
            echo -e "${RED}  - $var${NC}"
        done
        return 1
    fi

    return 0
}


services() {
    # check if services directory exists
    if [ ! -d "$PROJECT_ROOT/config/deploy" ]; then
        echo -e "${RED}Error: config/deploy directory not found.${NC}"
        return 1
    fi

    # pull up a comma separated list of services we have deploy scripts for
    local kamal_services=$(ls "$PROJECT_ROOT/config/deploy" | sed 's/.yml//' | paste -sd, -)
    if [ -z "$kamal_services" ]; then
        echo -e "${RED}Error: No services found'?"
        echo -e "${RED}Searched in: $PROJECT_ROOT/config/deploy"
        exit 1
    fi

    # parse the services from the .env.project file,
    #  format: <service_name>:<subdomain>:<domain>
    #  - subdomain may be empty (means root of domain)
    #  - domain is required and must be in DNS_ROOT_ZONES
    # Example: jax:jax:krondor.org,dev:dev:krondor.org,alexplain::alexplain.me

    # just get the names for the services
    local project_service_names=$(echo "$SERVICES" | tr ',' '\n' | cut -d':' -f1)

    # validate that kamal services align with project services --
    #  ensure that all kamal services are in the project services list
    for service in $(echo "$kamal_services" | tr ',' ' '); do
        if ! echo "$project_service_names" | grep -q "^${service}$"; then
            echo -e "${RED}Error: Service '$service' in config/deploy not found in .env.project"
            echo -e "${RED}Kamal services: $kamal_services"
            echo -e "${RED}Project services: $project_service_names"
            exit 1
        fi
    done

    # Build space-separated list of service:subdomain:domain triplets
    local service_list=""
    for service in $(echo "$kamal_services" | tr ',' ' '); do
        # Find the full config for this service from SERVICES variable
        local service_config=$(echo "$SERVICES" | tr ',' '\n' | grep "^${service}:")
        local subdomain=$(echo "$service_config" | cut -d':' -f2)
        local domain=$(echo "$service_config" | cut -d':' -f3)

        # Domain is required
        if [ -z "$domain" ]; then
            echo -e "${RED}Error: Service '$service' is missing domain (format: service:subdomain:domain)${NC}"
            exit 1
        fi

        # Validate domain is in DNS_ROOT_ZONES
        if ! echo "$DNS_ROOT_ZONES" | tr ',' '\n' | grep -q "^${domain}$"; then
            echo -e "${RED}Error: Service '$service' uses domain '$domain' which is not in DNS_ROOT_ZONES${NC}"
            echo -e "${RED}Available zones: $DNS_ROOT_ZONES${NC}"
            exit 1
        fi

        service_list+="${service}:${subdomain}:${domain} "
    done

    # Return space-separated list (trim trailing space)
    echo "${service_list% }"
}

# List just the service names (without subdomains)
# Usage: list_service_names
# Example: list_service_names -> "next py"
list_service_names() {
    local service_pairs=$(services)
    local names=""

    for service_pair in $service_pairs; do
        local service_name="${service_pair%%:*}"
        names+="$service_name "
    done

    # Return space-separated list (trim trailing space)
    echo "${names% }"
}

# List and validate stages
stages() {
    # check if stages directory exists
    if [ ! -d "$PROJECT_ROOT/iac/stages" ]; then
        echo -e "${RED}Error: iac/stages directory not found.${NC}"
        return 1
    fi

    # pull up a comma separated list of stages we have in iac/stages
    local iac_stages=$(ls "$PROJECT_ROOT/iac/stages" 2>/dev/null | paste -sd, -)
    if [ -z "$iac_stages" ]; then
        echo -e "${RED}Error: No stages found${NC}"
        echo -e "${RED}Searched in: $PROJECT_ROOT/iac/stages${NC}"
        exit 1
    fi

    # make sure that 'development' is not in the list of stages
    if echo "$iac_stages" | grep -q "development"; then
        echo -e "${RED}Error: 'development' stage is not allowed. There should be no reason to deploy development${NC}"
        exit 1
    fi

    # Return space-separated list of stages
    echo "$iac_stages" | tr ',' ' '
}

# Get the hostname for a service in a given stage
# Usage: get_service_hostname <service> <stage>
# Example: get_service_hostname jax production -> jax.krondor.org
# Example: get_service_hostname alexplain production -> alexplain.me
# Example: get_service_hostname jax staging -> staging.jax.krondor.org
get_service_hostname() {
    local service="$1"
    local stage="$2"

    if [ -z "$service" ] || [ -z "$stage" ]; then
        echo -e "${RED}Error: get_service_hostname requires service and stage arguments${NC}" >&2
        return 1
    fi

    # Find the service:subdomain:domain triplet from services() output
    local service_triplets=$(services)
    local subdomain=""
    local domain=""

    for service_triplet in $service_triplets; do
        local service_name=$(echo "$service_triplet" | cut -d':' -f1)
        if [ "$service_name" = "$service" ]; then
            subdomain=$(echo "$service_triplet" | cut -d':' -f2)
            domain=$(echo "$service_triplet" | cut -d':' -f3)
            break
        fi
    done

    # Start with just the domain
    local hostname="${domain}"

    # If the subdomain is not empty, then add the subdomain to the host name
    if [[ -n "$subdomain" ]]; then
        hostname="${subdomain}.${hostname}"
    fi

    # If the stage is not production, then add the stage to the host name
    if [[ "$stage" != "production" ]]; then
        hostname="${stage}.${hostname}"
    fi

    echo "$hostname"
}

# List all hostnames for a given stage
# Usage: list_hostnames <stage>
# Example: list_hostnames production
# Output: smols.org app.smols.org
list_hostnames() {
    local stage="$1"

    if [ -z "$stage" ]; then
        echo -e "${RED}Error: list_hostnames requires stage argument${NC}" >&2
        return 1
    fi

    local service_pairs=$(services)
    local hostnames=""

    for service_pair in $service_pairs; do
        local service_name="${service_pair%%:*}"
        local hostname=$(get_service_hostname "$service_name" "$stage")
        hostnames+="$hostname "
    done

    # Return space-separated list (trim trailing space)
    echo "${hostnames% }"
}

# List all unique domains from DNS_ROOT_ZONES
# Usage: list_unique_domains
# Example: list_unique_domains -> "krondor.org alexplain.me"
list_unique_domains() {
    echo "$DNS_ROOT_ZONES" | tr ',' ' '
}

# List all subdomains for a given stage and domain (for DNS record creation)
# Usage: list_subdomains_for_domain <stage> <domain>
# Example: list_subdomains_for_domain production krondor.org
# Output: jax dev (subdomains for services on that domain)
list_subdomains_for_domain() {
    local stage="$1"
    local target_domain="$2"

    if [ -z "$stage" ] || [ -z "$target_domain" ]; then
        echo -e "${RED}Error: list_subdomains_for_domain requires stage and domain arguments${NC}" >&2
        return 1
    fi

    local service_triplets=$(services)
    local subdomains=""

    for service_triplet in $service_triplets; do
        local service_name=$(echo "$service_triplet" | cut -d':' -f1)
        local subdomain=$(echo "$service_triplet" | cut -d':' -f2)
        local domain=$(echo "$service_triplet" | cut -d':' -f3)

        # Skip services not on this domain
        if [ "$domain" != "$target_domain" ]; then
            continue
        fi

        # If subdomain is empty, use @ for root
        if [ -z "$subdomain" ]; then
            subdomain="@"
        fi

        # If stage is not production, prepend stage to subdomain
        if [[ "$stage" != "production" ]]; then
            if [ "$subdomain" = "@" ]; then
                subdomain="$stage"
            else
                subdomain="${stage}.${subdomain}"
            fi
        fi

        subdomains+="$subdomain "
    done

    # Return space-separated list (trim trailing space)
    echo "${subdomains% }"
}

# List all subdomains for a given stage (for backward compatibility)
# DEPRECATED: Use list_subdomains_for_domain instead for multi-domain setups
# Usage: list_subdomains <stage>
# Output: all subdomains across all domains
list_subdomains() {
    local stage="$1"

    if [ -z "$stage" ]; then
        echo -e "${RED}Error: list_subdomains requires stage argument${NC}" >&2
        return 1
    fi

    local all_subdomains=""
    for domain in $(list_unique_domains); do
        local domain_subdomains=$(list_subdomains_for_domain "$stage" "$domain")
        all_subdomains+="$domain_subdomains "
    done

    # Return space-separated list (trim trailing space)
    echo "${all_subdomains% }"
}

# Export service hostnames as environment variables for a given stage
# Usage: export_service_hostnames <stage>
# Example: export_service_hostnames production
# Sets: NEXT_HOST_NAME=smols.org PY_HOST_NAME=app.smols.org
export_service_hostnames() {
    local stage="${1}"
    # if stage is not set, fail loudly
    if [[ -z "$stage" ]]; then
        echo -e "${RED}Error: Stage not set"
        exit 1
    fi

    # Get all services
    local service_pairs=$(services)

    for service_pair in $service_pairs; do
        local service_name="${service_pair%%:*}"
        local hostname=$(get_service_hostname "$service_name" "$stage")

        # Convert service name to uppercase and replace dashes with underscores
        local var_name=$(echo "${service_name}" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
        var_name="${var_name}_HOST_NAME"

        # Export the variable
        export "${var_name}=${hostname}"
    done
}

source_project_config

# TODO (amiller68): this does not give a good error message
# Now validate services after config is loaded
if ! services > /dev/null; then
    exit 1
fi

# Check if script is being sourced or executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    source $PROJECT_ROOT/bin/utils
    # Script is being executed directly - print configuration summary
    print_header "Project Configuration"

    echo ""
    print_info "Project:"
    echo "  Name: $PROJECT_NAME"
    echo "  Cloud Vault: $CLOUD_VAULT"

    echo ""
    print_info "DNS Zones:"
    for zone in $(list_unique_domains); do
        echo "  - $zone"
    done

    echo ""
    print_info "Services:"
    for service_triplet in $(services); do
        service_name=$(echo "$service_triplet" | cut -d':' -f1)
        subdomain=$(echo "$service_triplet" | cut -d':' -f2)
        domain=$(echo "$service_triplet" | cut -d':' -f3)
        if [ -z "$subdomain" ]; then
            echo "  - $service_name -> $domain (root)"
        else
            echo "  - $service_name -> $subdomain.$domain"
        fi
    done

    echo ""
    print_info "Stages:"
    for stage in $(stages); do
        echo "  - $stage"
    done

    echo ""
    print_info "Production Hostnames:"
    for service_triplet in $(services); do
        service_name=$(echo "$service_triplet" | cut -d':' -f1)
        hostname=$(get_service_hostname "$service_name" "production")
        echo "  - $service_name: $hostname"
    done

    echo ""
    print_info "DNS Records per Zone (production):"
    for zone in $(list_unique_domains); do
        subdomains=$(list_subdomains_for_domain "production" "$zone")
        echo "  $zone: $subdomains"
    done

    echo ""
    echo -e "${GRAY}Note: This script is meant to be sourced by other scripts.${NC}"
    echo -e "${GRAY}Available functions: services, stages, get_service_hostname, list_hostnames, list_subdomains_for_domain, etc.${NC}"
else
    # source the project config at the top (but skip service validation to avoid circular dependency)
    source_project_config

    # Now validate services after config is loaded
    if ! services > /dev/null; then
        exit 1
    fi

    export STAGES=$(stages)
fi
